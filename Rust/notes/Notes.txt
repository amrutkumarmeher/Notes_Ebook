>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> [ RUST NOTES ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

............ { Comment }...........
-> Single line:
  -e.g.  // This is a comment
-> Multi-line:
  -e.g. /**/

............ { Declaration }...........

let mut(optional) <identifier> : <type>(optional) = <value>;
for global variables we have two keywords:
const: used for constants at compile time, in lined & not fined memory location.
static: used for mutable or immutable at runtime, fixed memory location.

............ { Datatypes }.............
-> Primitive Datatypes
- int, char, bool, float

_ Integer(int):
  -> signed:   i8, i16, i32, i64, i128
  -> unsigned: u8, u16, u32, u64, u128
_ float(float):
  -> f32 & f64
_ Boolean(bool):
  -> bool(true or false)
_ character(char):
  -> char(single Unicode character value, e.g. '\u{30}'.

-> Non-Primitive Datatype
- array, tuple, slice, string, slice string.

_ array
 -> declaration: let <identifier>: [<datatype>, <arrsize>] = [<value>,<value>...];
_ string(String)
 -> collection of character & owns them.
 -> we can make a slice string from a string:  &<string var>[<string index>..<last index>]
_ slices string(&str)
 -> Immutable

_ tuple
 -> collection of elements(different data type).
 -> declaration: let <identifier>

............ { Functions }.............

- declared with fn keyword.
- function name should be in snake case with only lower case letters.
- function can be above or below main() function.

 _ syntax:
_____________________________________________
|   fn <name_in_snake_case>( <arg>: <type>){|
|      // code inside                       |
|     }                                     |
|___________________________________________|
- it will return output of last expression when we close a code block(braces).
- last line of code doesn't need any braces.
E.g.: 
________________
| fn main(){   |
|     line1;   |
|     line last|
|  }           |
|______________|

- whatever line last return gonna be return value of main funs too.
- alternative of it is using 'return' statement.
- the println! macro can be formatted in this way: "{<digits before dot>.<digits after dots>}"

Expression: sentence that returns a value.
E.g.. 
__________________________________
|    5 // returns 5              |
|    true // returns true        |
|    add(1,2) // returns int 3   |
|    if(con){value1} else{value2}|
|________________________________|

Statement:  sentence that doesn't returns a value.
 - its something that can't be assigned to a variable.
 - its something that doesn't return values.
 - E.g.:
   -> declaration of variable is a statement.
   -> function definition.
   -> control statement.

............ { Ownership & Borrowing }.............
- Ownership: every value has one owner, some of the variables own its value.
  - Whenever the owner goes out of scope, its value will be dropped.
- Reference: Its like pointer in C, its a reference to an existing value in memory & borrowing its.
  - Borrowing is of two types: mutable(borrow with modification) & immutable(only use).
  - whenever you use reference to a value existed in memory, we use '&' sign in front of the var.
  - we can use this sign to borrow a value from its owner.
  - whenever are modifying the reference value(mutable), we use '*' sign in front of the var.
  - You can have one mutable reference or many immutable references.


............ { Data Structure }.............
->  STRUCT
   - it has fields with data types.
   - you can create an instance of a struct.
   - in this case 'i' is the instance.
   - the entire struct object must be mutable in order to modify it at runtime.
   - its an object means we can use to process values & use its objects as return values.
   - we can create an instance with the help of another by copying. Syntax:
    ____________________________
    |  let user2 = user{       |
    |    email: "some@m.com";  |
    |    ..user1               |
    |__________________________|
   - we can copy other field from user1(another instance) to user to except email.
   - email field set manually.
   - Syntax:
____________________________________________
| struct <name>{                           |
|    <var1>:<datatype>,                    |
|    <var2>:<datatype>                     |
| }                                        |
| impl <name>{                             |
|   fn <fn_name>(self,<args:datatypes>){}  |
|  }                                       |
|                                          |
| // declaring                             |
| fn main(){                               |
|  let i : struct = <name>{                |
|   <var1>:<val1>,                         |
|   <var2>:<val2>                          |
|  }                                       |
|  i.<fn_name>()                           |
| }                                        |
|__________________________________________|

-> Tuple Struct
   - contain only values with no keywords.
   - Syntax:
     _____________________________
     |  struct a(i32, i32, i32); |
     |  let x = a(1,2,3)         |
     |___________________________|
 
-> Unit struct or no value struct
    - doesn't contain any value.
    - Syntax:
     _____________________________
     |   struct a;               |
     |   let x = a;              |
     |___________________________|

............ { Constants }.............

-> Difference between constant & immutable:
  - in constants you are not allowed to use the keyword 'mut' with 'const'.
  - when declaring a constant, it should be in capital letter.
  - while declaring a constant, the datatype must be specified.
  - constant can be declared anywhere, in global scope(outside of main function).

............ { Shadowing }.............

-> Shadowing is a technic same as overwriting in other languages.
-> It allows an existing variable to redeclared in a particular scope, allowing a particular value for a block..
-> It will retain its old value if the shadowed(second, or more) got out of scope.
-> we can do shadowing with different types of data.
e.g.:
_____________________________________________________________________
|                                                                   |
|    let shadowed_binding = 1;                                      |
|    {                                                              |
|        println!("before being shadowed: {}", shadowed_binding);   |
|        // This binding *shadows* the outer one                    |
|        let shadowed_binding = "abc";                              |
|        println!("shadowed in inner block: {}", shadowed_binding); |
|    }                                                              |
|    println!("outside inner block: {}", shadowed_binding);         |
|    // This binding *shadows* the previous binding                 |
|    let shadowed_binding = 2;                                      |
|    println!("shadowed in outer block: {}", shadowed_binding);     |
|___________________________________________________________________|

............ { If-Else Condition }...........

Syntax:
___________________________
| if <condition> {        |
|  // code                |
| } else if <condition> { |
|  // code                |
| } else {                |
|  // code                |
| }                       |
|_________________________|

............ { Loops & Repetition }...........

Types of loop:
-> loop:
   - repeat util got hit by break statement.
   - also return values at the end.
   - values aside of break statement are returned.
 ___________________________
 | loop{                   |
 |  // code                |
 |  if <condition>{        |
 |    break 1;             |
 |  }                      |
 | }                       |
 |_________________________|

    -> LABELS:
       - in case of nested loops, label can be used to label the code block.
       - these are useful to break the nested loop suddenly & came out of a level nested loop with break & label.
       - labels are created by ' & set like: '<label name>: <loops>;
       - Syntax:
        ___________________________________________
        | 'label1: loop{                          |
        |   'label2:loop{                         |
        |      // inside nested loop              |
        |      break 'label1;                     |
        |      print!("This will never reached"); |
        |    }                                    |
        |  }                                      |
        |_________________________________________|

       - in this case, when it breaks 'label1, it will suddenly break first loop & stop second loop before print statement.

-> while loop:
   - loop until a condition is met.
   - Syntax:
     _________________________________
     | while <condition> {           |
     |    // code                    |
     |  }                            |
     |_______________________________|

 -> for each:
   - loop through series or list.
   - Syntax:
     ________________________________
     |  for i in array{             |
     |    // code                   |
     |______________________________|







