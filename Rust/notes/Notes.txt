>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> [ RUST NOTES ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

............ { Comment }...........
-> Single line:
  -e.g.  // This is a comment
-> Multi-line:
  -e.g. /**/

............ { Declaration }...........

let mut(optional) <identifier> : <type>(optional) = <value>;
for global variables we have two keywords:
const: used for constants at compile time, in lined & not fined memory location.
static: used for mutable or immutable at runtime, fixed memory location.

............ { Datatypes }.............
-> Primitive Datatypes
- int, char, bool, float

_ Integer(int):
  -> signed:   i8, i16, i32, i64, i128
  -> unsigned: u8, u16, u32, u64, u128
_ float(float):
  -> f32 & f64
_ Boolean(bool):
  -> bool(true or false)
_ character(char):
  -> char(single Unicode character value, e.g. '\u{30}'.

-> Non-Primitive Datatype
- array, tuple, slice, string, slice string.

_ array
 -> declaration: let <identifier>: [<datatype>, <arrsize>] = [<value>,<value>...];
_ string(String)
 -> collection of character & owns them.
 -> we can make a slice string from a string:  &<string var>[<string index>..<last index>]
_ slices string(&str)
 -> Immutable

_ tuple
 -> collection of elements(different data type).
 -> declaration: let <identifier>

............ { Functions }.............

- declared with fn keyword.
- function name should be in snake case with only lower case letters.
- function can be above or below main() function.

 _ syntax:
_____________________________________________
|   fn <name_in_snake_case>( <arg>: <type>){|
|      // code inside                       |
|     }                                     |
|___________________________________________|
- it will return output of last expression when we close a code block(braces).
- last line of code doesn't need any braces.
E.g.: 
________________
| fn main(){   |
|     line1;   |
|     line last|
|  }           |
|______________|

- whatever line last return gonna be return value of main funs too.
- alternative of it is using 'return' statement.
- the println! macro can be formatted in this way: "{<digits before dot>.<digits after dots>}"

Expression: sentence that returns a value.
E.g.. 
__________________________________
|    5 // returns 5              |
|    true // returns true        |
|    add(1,2) // returns int 3   |
|    if(con){value1} else{value2}|
|________________________________|

Statement:  sentence that doesn't returns a value.
 - its something that can't be assigned to a variable.
 - its something that doesn't return values.
 - E.g.:
   -> declaration of variable is a statement.
   -> function definition.
   -> control statement.

............ { Control Flow }.............

-> If-else:
   - use the keyword if, else, if else to control with help of expressions.
-> match <var>:
   - just like switch in other languages, it recognise patters & execute instructions if any of these matched.

............ { Ownership & Borrowing }.............
- Ownership: every value has one owner, some of the variables own its value.
  - Whenever the owner goes out of scope, its value will be dropped.
- Reference: Its like pointer in C, its a reference to an existing value in memory & borrowing its.
  - Borrowing is of two types: mutable(borrow with modification) & immutable(only use).
  - whenever you use reference to a value existed in memory, we use '&' sign in front of the var.
  - we can use this sign to borrow a value from its owner.
  - whenever are modifying the reference value(mutable), we use '*' sign in front of the var.
  - You can have one mutable reference or many immutable references.


............ { Data Structure }.............
->  STRUCT
   - it has fields with data types.
   - you can create an instance of a struct.
   - in this case 'i' is the instance.
   - the entire struct object must be mutable in order to modify it at runtime.
   - its an object means we can use to process values & use its objects as return values.
   - we can create an instance with the help of another by copying. Syntax:
    ____________________________
    |  let user2 = user{       |
    |    email: "some@m.com";  |
    |    ..user1               |
    |__________________________|
   - we can copy other field from user1(another instance) to user to except email.
   - email field set manually.
   - Syntax:
____________________________________________
| struct <name>{                           |
|    <var1>:<datatype>,                    |
|    <var2>:<datatype>                     |
| }                                        |
| impl <name>{                             |
|   fn <fn_name>(self,<args:datatypes>){}  |
|  }                                       |
|                                          |
| // declaring                             |
| fn main(){                               |
|  let i : struct = <name>{                |
|   <var1>:<val1>,                         |
|   <var2>:<val2>                          |
|  }                                       |
|  i.<fn_name>()                           |
| }                                        |
|__________________________________________|

-> Tuple Struct
   - contain only values with no keywords.
   - Syntax:
     _____________________________
     |  struct a(i32, i32, i32); |
     |  let x = a(1,2,3)         |
     |___________________________|
 
-> Unit struct or no value struct
    - doesn't contain any value.
    - Syntax:
     _____________________________
     |   struct a;               |
     |   let x = a;              |
     |___________________________|

-> Enum
   - contain different variants of its type during declaration.
   - only one variant can be used in an object at a time.
   - Only one type of data can be stored at a time which is variant value.
   - it can be used to pass choices to functions, its type identified as Enum name.
   - Syntax:
     __________________________________
     | enum aenum{                    |
     |    varient1,varient2           |
     | }                              |
     | let x:aenum = aenum::varient1; |
     |________________________________|
   - If we wanna store data, Syntax:
     ________________________________________
     | Enum aenum {                         |
     |   varient1(<datatype>),              |
     |   varient2(<datatype>,<datatype)     |
     | }                                    |
     | let x:aenum = aenum::varient1(<val>);|
     |______________________________________|
   

............ { Constants }.............

-> Difference between constant & immutable:
  - in constants you are not allowed to use the keyword 'mut' with 'const'.
  - when declaring a constant, it should be in capital letter.
  - while declaring a constant, the datatype must be specified.
  - constant can be declared anywhere, in global scope(outside of main function).

............ { Shadowing }.............

-> Shadowing is a technic same as overwriting in other languages.
-> It allows an existing variable to redeclared in a particular scope, allowing a particular value for a block..
-> It will retain its old value if the shadowed(second, or more) got out of scope.
-> we can do shadowing with different types of data.
e.g.:
_____________________________________________________________________
|                                                                   |
|    let shadowed_binding = 1;                                      |
|    {                                                              |
|        println!("before being shadowed: {}", shadowed_binding);   |
|        // This binding *shadows* the outer one                    |
|        let shadowed_binding = "abc";                              |
|        println!("shadowed in inner block: {}", shadowed_binding); |
|    }                                                              |
|    println!("outside inner block: {}", shadowed_binding);         |
|    // This binding *shadows* the previous binding                 |
|    let shadowed_binding = 2;                                      |
|    println!("shadowed in outer block: {}", shadowed_binding);     |
|___________________________________________________________________|

............ { If-Else Condition }...........

Syntax:
___________________________
| if <condition> {        |
|  // code                |
| } else if <condition> { |
|  // code                |
| } else {                |
|  // code                |
| }                       |
|_________________________|

............ { Loops & Repetition }...........

Types of loop:
-> loop:
   - repeat util got hit by break statement.
   - also return values at the end.
   - values aside of break statement are returned.
 ___________________________
 | loop{                   |
 |  // code                |
 |  if <condition>{        |
 |    break 1;             |
 |  }                      |
 | }                       |
 |_________________________|

    -> LABELS:
       - in case of nested loops, label can be used to label the code block.
       - these are useful to break the nested loop suddenly & came out of a level nested loop with break & label.
       - labels are created by ' & set like: '<label name>: <loops>;
       - Syntax:
        ___________________________________________
        | 'label1: loop{                          |
        |   'label2:loop{                         |
        |      // inside nested loop              |
        |      break 'label1;                     |
        |      print!("This will never reached"); |
        |    }                                    |
        |  }                                      |
        |_________________________________________|

       - in this case, when it breaks 'label1, it will suddenly break first loop & stop second loop before print statement.

-> while loop:
   - loop until a condition is met.
   - Syntax:
     _________________________________
     | while <condition> {           |
     |    // code                    |
     |  }                            |
     |_______________________________|

 -> for each:
   - loop through series or list.
   - Syntax:
     ________________________________
     |  for i in array{             |
     |    // code                   |
     |______________________________|

............ { Error & Exception handling }...........

-> Approach 1(Option<T>):
   - Option<...> is an Enum which stores two variants, value(some(...)) or None.
   - It can be used in case of error, it can process valueless variable.
   - It can be return type of a function, in case it didn't provide any value.
   - In this Enum, there are two variants: some(<val>) & None. 
   - defining an Enum to set return type is a clever way, & putting none as a variant.
   - Syntax:
     _______________________________________
     | fn div(a:i32, b:i32)->Option<i32>{  |
     |   if b == 0{None}                   |
     |   else { some(a/b)}                 |
     | }                                   |
     |_____________________________________|

-> Approach 2(Result<T,E>):
   - just like option Enum, its also an Enum with two variants: Ok(...) & Err(...).
   - it will create obj of Ok variant if everything is ok else of Err.
   - we can get <val> from Ok(<val>) by .unwrap() function.
     ____________________________________________
     | fn div(a:i32, b:i32)->Result<i32,&str>{  |
     |   if b == 0{Err("Cant div")}             |
     |   else {Ok(a/b)}                         |
     | }                                        |
     |__________________________________________|

............ { Macro }...........

   - Its a type of function that input some code & output some code.
   - Its part of metaprogramming.
   - All the procedure & changes happen during AST(ASynatx Tree) during compilation of code.
-> Declarative macro:
   - similar to rust match expression, matches the pattern & execute code based on it.
   - Declaration Syntax:
   ______________________________________________________
   | macro_rules! amacro{                               |
   |   () => {}; // if nothing got. do everything in {} |
   |   (<some pattern>) => {<do something>}             |
   | }                                                  |
   |____________________________________________________|
    
   - <some pattern> can be an arbitrary var to specify input code or patterns.
   - its name started with $ like $someval: <type>, <type> specify type of code & pattern.
   - its type can be:
   __________________________________________________________________
   |         Keyword          |                used for             |
   |--------------------------|-------------------------------------|
   |          item            |   item like func, struct, module.   |
   |          block           |        a group of statement.        |
   |          stmt            |  stands for statementdo action,     |
   |                          |   doesn't return anything.          |
   |          pat             | patterns, literals, variables, DS.  |
   |          expr            | an expression which returns value.  |
   |          ty              | a type, type or class of an object. |
   |          ident           |  an identifier or variable name.    |
   |          path            | reference like func, Enum, struct.  |
   |__________________________|_____________________________________|

   - If we wanna do repetition in macro input. we can do it by pattern $($<identifier>:<type>),<repetition symbol>.
   - In this syntax, ',' is separator which is optional.
   - * repetition symbol is compulsory, its of 3 types based on how much to repeat:
   ______________________________________________
   |       Symbol       |         Range         |
   |--------------------|-----------------------|
   |         *          |       0 - many        |
   |         +          |       1 - many        |
   |         ?          |        0 - 1          |
   |____________________|_______________________|   
   - separator can be in between $ to <*/?/+>. its used to denote comma in input.
   - we can use &(<code>)* to write loop in list like inputs:
   _______________________________________________________
   | macro_rules! amacro{                                |
   |   ($($x:expr),*){                                   |
   |      $( println!("{}",$x);)*                        |
   |   }                                                 |
   | }                                                   |
   |_____________________________________________________|
   - note: ',' is a separator of this pattern, think of something like amacro!(1|2|3), the separator will change to '|'.
   - its only placed to recognise patterns.
   - In case if first value got taken separately by a different pattern like in recursion, it will place before $x:<t>.


............ { Collection Types }...........

-> Vector(Vec<T>):
   - T here is datatype.
   - It stores value one after another just like array.
   - the only difference between vector & array is, vector can change dynamically.
   - In rust there is a macro vec![<values>] used to initialize a vector.

-> UTF-8 Strings:
   - to create: String::from("some str") or String::new().
   - These strings are UTF-8 encoded, means it can represent characters of other languages.
   - It can store emojis.
   - In rust, string(one owned with another borrowed) can be added with the sign of +.

-> Hash-Map:
   - to create a new one: HashMap::new().
   - to initialize: let mut _a: HashMap<<Key type>,<val type>> = HashMap::new();.
   - insert: _a.insert(<key>,<val>);.
   - get: _a.get(<key>);. It will return value associated with that key.
   - It will return Some(<val).
   



